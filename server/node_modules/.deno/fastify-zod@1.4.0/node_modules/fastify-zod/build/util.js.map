{"version":3,"file":"util.js","names":["_zod","require","isZod","Type","input","parse","exports","ZodShape","shape","z","object","strict","isRecord","Array","isArray","mapDeep","current","replace","k","length","Object","keys","findFirstDeep","predicate","path","push","found","value","pop","visitDeep","visit"],"sources":["../src/util.ts"],"sourcesContent":["import { ZodSchema, ZodType, z } from \"zod\";\n\nexport const isZod =\n  <T>(Type: ZodType<T>) =>\n  (input: unknown): input is T => {\n    try {\n      Type.parse(input);\n      return true;\n    } catch {\n      return false;\n    }\n  };\nexport type ZodShape<T> = {\n  // Require all the keys from T\n  [key in keyof T]-?: undefined extends T[key]\n    ? // When optional, require the type to be optional in zod\n      z.ZodOptionalType<z.ZodType<T[key]>>\n    : z.ZodType<T[key]>;\n};\n\nexport const ZodShape = <T>(shape: ZodShape<T>): ZodSchema<T> =>\n  z.object(shape).strict() as unknown as ZodSchema<T>;\n\nexport const isRecord = (input: unknown): input is Record<string, unknown> =>\n  !Array.isArray(input) && typeof input === `object` && input !== null;\n\nexport const mapDeep = (\n  current: unknown,\n  replace: (value: unknown) => void,\n): unknown => {\n  if (Array.isArray(current)) {\n    for (let k = 0; k < current.length; k++) {\n      current[k] = replace(mapDeep(current[k], replace));\n    }\n  } else if (isRecord(current)) {\n    for (const k of Object.keys(current)) {\n      current[k] = replace(mapDeep(current[k], replace));\n    }\n  }\n  return current;\n};\n\nexport const findFirstDeep = (\n  current: unknown,\n  predicate: (value: unknown, path: string[]) => boolean,\n  path: string[] = [],\n): [found: boolean, value: unknown, path: string[]] => {\n  if (predicate(current, path)) {\n    return [true, current, path];\n  }\n  if (Array.isArray(current)) {\n    for (let k = 0; k < current.length; k++) {\n      path.push(`${k}`);\n      const [found, value] = findFirstDeep(current[k], predicate, path);\n      if (found) {\n        return [found, value, path];\n      }\n      path.pop();\n    }\n    return [false, null, []];\n  }\n  if (isRecord(current)) {\n    for (const k of Object.keys(current)) {\n      path.push(k);\n      const [found, value] = findFirstDeep(current[k], predicate, path);\n      if (found) {\n        return [found, value, path];\n      }\n      path.pop();\n    }\n    return [false, null, []];\n  }\n  return [false, null, []];\n};\n\nexport const visitDeep = (\n  current: unknown,\n  visit: (value: unknown, path: string[]) => void,\n  path: string[] = [],\n): void => {\n  visit(current, path);\n  if (Array.isArray(current)) {\n    for (let k = 0; k < current.length; k++) {\n      path.push(`${k}`);\n      visitDeep(current[k], visit, path);\n      path.pop();\n    }\n    return;\n  }\n  if (isRecord(current)) {\n    for (const k of Object.keys(current)) {\n      path.push(k);\n      visitDeep(current[k], visit, path);\n      path.pop();\n    }\n    return;\n  }\n  return;\n};\n"],"mappings":"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"}