{"version":3,"file":"SpecTransformer.js","names":["_util","require","_changeCase","_fastDeepEqual","_interopRequireDefault","_Path","_util2","obj","__esModule","default","isRef","ref","isRecord","$ref","toRefPath","indexOfPath","indexOf","basePath","slice","path","split","toRef","refPath","join","isSpecSchema","input","properties","additionalProperties","patternProperties","items","isSpecSchemas","value","Object","values","isOpenApiSpec","components","paths","schemas","isSwaggerSpec","definitions","isSpec","deepClone","spec","JSON","parse","stringify","defaultExtractSchemaPropertiesKey","withTimings","fn","begin","performance","now","result","end","delta","SpecTransformer","constructor","DEBUG","Error","schemasPath","initialSchemaKeys","getSchemaKeys","_DEBUG","args","console","debug","throw","error","inspect","depth","getSchemaPath","schemaKey","getChildPath","getSchema","schema","getAtPath","keys","createSchemaKey","parentSchemaKey","schemaKeysOptions","parts","removeInitialSchemasPrefix","includes","push","baseName","changeCase","pascalCase","camelCase","paramCase","snakeCase","getAtPathSafe","resolveRef","length","nextRef","setAtPath","deleteAtPath","findFirstDeep","predicate","hasProperRef","schemaPath","equalPath","matchPathPrefix","deleteUnusedSchemas","dirty","rewriteSchemaAbsoluteRefs","visitDeep","nextPath","rewriteSchemasAbsoluteRefs","extractSchemaPathAsSchema","prevSchemaKey","prevRelativePath","nextSchemaKey","prevPath","prevValue","hasValueAtNextPath","valueAtNextPath","deepEqual","replacePathPrefix","extractSchemaPropertiesAtKey","propertiesKey","globalDirty","k","property","extractSchemaProperties","propertiesKeys","extractSchemasProperties","mergeRef","prev$ref","next$ref","mergeRefs","$refs","transformWithTimings","opts","total","map","extractSchemasPropertiesKeys","Array","isArray","schemaKeys","timings","transform","exports"],"sources":["../src/SpecTransformer.ts"],"sourcesContent":["import { inspect } from \"util\";\n\nimport { camelCase, pascalCase, snakeCase, paramCase } from \"change-case\";\nimport deepEqual from \"fast-deep-equal\";\n\nimport {\n  deleteAtPath,\n  equalPath,\n  getAtPath,\n  getAtPathSafe,\n  getChildPath,\n  matchPathPrefix,\n  replacePathPrefix,\n  setAtPath,\n} from \"./Path\";\nimport { findFirstDeep, isRecord, visitDeep } from \"./util\";\n\ntype Ref = {\n  $ref: string;\n};\n\nconst isRef = (ref: unknown): ref is Ref => {\n  if (!isRecord(ref)) {\n    return false;\n  }\n  return typeof ref.$ref === `string`;\n};\n\ntype RefPath = {\n  readonly basePath: string;\n  readonly path: string[];\n};\n\nconst toRefPath = ($ref: string): RefPath => {\n  const indexOfPath = $ref.indexOf(`#`);\n  return {\n    basePath: $ref.slice(0, indexOfPath),\n    path: $ref\n      .slice(indexOfPath + 1)\n      .split(`/`)\n      .slice(1),\n  };\n};\n\nconst toRef = (refPath: RefPath): Ref => ({\n  $ref: [`${refPath.basePath}#`, ...refPath.path].join(`/`),\n});\n\ntype SpecSchema = {\n  readonly properties?: Record<string, unknown>;\n  readonly additionalProperties?: boolean | Record<string, unknown>;\n  readonly patternProperties?: Record<string, unknown>;\n  readonly items?: Record<string, unknown>;\n};\n\nconst isSpecSchema = (input: unknown): input is SpecSchema => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { properties, additionalProperties, patternProperties, items } = input;\n  if (typeof properties !== `undefined` && !isRecord(properties)) {\n    return false;\n  }\n\n  if (\n    typeof additionalProperties !== `undefined` &&\n    typeof additionalProperties !== `boolean` &&\n    !isRecord(additionalProperties)\n  ) {\n    return false;\n  }\n\n  if (\n    typeof patternProperties !== `undefined` &&\n    typeof patternProperties !== `boolean` &&\n    !isRecord(patternProperties)\n  ) {\n    return false;\n  }\n\n  if (typeof items !== `undefined` && !isRecord(items)) {\n    return false;\n  }\n\n  return true;\n};\n\ntype SpecSchemas = Record<string, SpecSchema>;\n\nconst isSpecSchemas = (input: unknown): input is SpecSchemas => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  for (const value of Object.values(input)) {\n    if (!isSpecSchema(value)) {\n      return false;\n    }\n  }\n  return true;\n};\n\ntype OpenApiSpec = {\n  readonly components: {\n    readonly schemas: SpecSchemas;\n  };\n  readonly paths?: Record<string, unknown>;\n};\n\nconst isOpenApiSpec = (input: unknown): input is OpenApiSpec => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { components, paths } = input;\n  if (!isRecord(components)) {\n    return false;\n  }\n  const { schemas } = components;\n  if (!isSpecSchemas(schemas)) {\n    return false;\n  }\n  if (typeof paths !== `undefined` && !isRecord(paths)) {\n    return false;\n  }\n  return true;\n};\n\ntype SwaggerSpec = {\n  readonly definitions: SpecSchemas;\n  readonly paths?: Record<string, unknown>;\n};\n\nconst isSwaggerSpec = (input: unknown): input is SwaggerSpec => {\n  if (!isRecord(input)) {\n    return false;\n  }\n  const { definitions, paths } = input;\n  if (!isSpecSchemas(definitions)) {\n    return false;\n  }\n  if (typeof paths !== `undefined` && !isRecord(paths)) {\n    return false;\n  }\n  return true;\n};\n\nexport type Spec = OpenApiSpec | SwaggerSpec;\n\nconst isSpec = (input: unknown): input is Spec =>\n  isOpenApiSpec(input) || isSwaggerSpec(input);\n\nconst deepClone = (spec: Spec): Spec => JSON.parse(JSON.stringify(spec));\n\ntype ExtractSchemaPropertiesKey =\n  | `properties`\n  | `additionalProperties`\n  | `patternProperties`\n  | `items`;\n\nconst defaultExtractSchemaPropertiesKey: ExtractSchemaPropertiesKey[] = [\n  `properties`,\n  `additionalProperties`,\n  `patternProperties`,\n  `items`,\n];\n\ntype Timings = {\n  readonly begin: number;\n  readonly end: number;\n  readonly delta: number;\n};\n\nconst withTimings = <T>(fn: () => T): [result: T, timings: Timings] => {\n  const begin = performance.now();\n  const result = fn();\n  const end = performance.now();\n\n  return [\n    result,\n    {\n      begin,\n      end,\n      delta: end - begin,\n    },\n  ];\n};\n\ntype TransformWithTimingsResult = {\n  readonly spec: Spec;\n  readonly timings: {\n    readonly rewriteSchemasAbsoluteRefs: Timings;\n    readonly extractSchemasProperties: Timings;\n    readonly mergeRefs: Timings;\n    readonly deleteUnusedSchemas: Timings;\n    readonly total: Timings;\n  };\n};\n\ntype SchemaKeysOptions = {\n  readonly removeInitialSchemasPrefix?: boolean;\n  readonly changeCase?:\n    | `preserve`\n    | `camelCase`\n    | `PascalCase`\n    | `snake_case`\n    | `param-case`;\n};\n\nexport type TransformOptions = {\n  readonly rewriteSchemasAbsoluteRefs?: boolean;\n  readonly extractSchemasProperties?: boolean | ExtractSchemaPropertiesKey[];\n  readonly mergeRefs?: Ref[];\n  readonly deleteUnusedSchemas?: boolean;\n  readonly schemaKeys?: SchemaKeysOptions;\n};\n\nexport class SpecTransformer {\n  private readonly DEBUG: boolean;\n  private readonly spec: Spec;\n  private readonly initialSchemaKeys: string[];\n\n  private readonly schemasPath: string[];\n\n  public constructor(spec: unknown, DEBUG = false) {\n    if (!isSpec(spec)) {\n      throw new Error(`spec is not an OpenApiSpec or a SwaggerSpec`);\n    }\n    this.spec = deepClone(spec);\n    this.schemasPath = isOpenApiSpec(spec)\n      ? [`components`, `schemas`]\n      : [`definitions`];\n    this.initialSchemaKeys = this.getSchemaKeys();\n    this.DEBUG = DEBUG;\n  }\n\n  private readonly _DEBUG = (...args: unknown[]): void => {\n    if (this.DEBUG) {\n      console.debug(...args);\n    }\n  };\n\n  private readonly throw = (error: unknown): never => {\n    if (this.DEBUG) {\n      console.debug(inspect(this.spec, { depth: null }));\n      console.error(error);\n    }\n    throw error;\n  };\n\n  private readonly getSchemaPath = (schemaKey: string): string[] =>\n    getChildPath(getChildPath(this.schemasPath, schemaKey));\n\n  private readonly getSchema = (schemaKey: string): SpecSchema => {\n    const schema = this.getAtPath(this.getSchemaPath(schemaKey));\n    if (!isSpecSchema(schema)) {\n      return this.throw(new Error(`schema is not a SpecSchema`));\n    }\n    return schema;\n  };\n\n  private readonly getSchemaKeys = (): string[] => {\n    const schemas = this.getAtPath(this.schemasPath);\n    if (!isRecord(schemas)) {\n      return this.throw(new Error(`schemas is not a Record`));\n    }\n    return Object.keys(schemas);\n  };\n\n  private readonly createSchemaKey = (\n    parentSchemaKey: string,\n    path: string[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): string => {\n    const parts: string[] = [];\n    if (\n      !schemaKeysOptions?.removeInitialSchemasPrefix ||\n      !this.initialSchemaKeys.includes(parentSchemaKey)\n    ) {\n      parts.push(parentSchemaKey);\n    }\n    parts.push(...path);\n    const baseName = parts.join(`_`);\n    const schemaKey =\n      schemaKeysOptions?.changeCase === `PascalCase`\n        ? pascalCase(baseName)\n        : schemaKeysOptions?.changeCase === `camelCase`\n        ? camelCase(baseName)\n        : schemaKeysOptions?.changeCase === `param-case`\n        ? paramCase(baseName)\n        : schemaKeysOptions?.changeCase === `snake_case`\n        ? snakeCase(baseName)\n        : baseName;\n    if (this.getSchemaKeys().includes(schemaKey)) {\n      throw new Error(`schemaKey(schemaKey='${schemaKey}') already exists`);\n    }\n    return schemaKey;\n  };\n\n  private readonly getAtPath = (path: string[]): unknown =>\n    getAtPath(this.spec, path);\n\n  private readonly getAtPathSafe = (\n    path: string[],\n  ): [valueFound: boolean, value: unknown] => getAtPathSafe(this.spec, path);\n\n  private readonly resolveRef = (\n    $ref: string,\n  ): [value: unknown, $ref: string] => {\n    const refPath = toRefPath($ref);\n    if (refPath.basePath.length > 0) {\n      const nextRef = toRef({\n        basePath: ``,\n        path: getChildPath(\n          this.getSchemaPath(refPath.basePath),\n          ...refPath.path,\n        ),\n      });\n      return this.resolveRef(nextRef.$ref);\n    }\n    const value = this.getAtPath(refPath.path);\n    if (isRef(value)) {\n      return this.resolveRef(value.$ref);\n    }\n    return [value, $ref];\n  };\n\n  private readonly setAtPath = (path: string[], value: unknown): void => {\n    this._DEBUG(`setAtPath`, { path, value });\n    return setAtPath(this.spec, path, value);\n  };\n\n  private readonly deleteAtPath = (path: string[]): void => {\n    this._DEBUG(`deleteAtPath`, { path });\n    return deleteAtPath(this.spec, path);\n  };\n\n  private readonly findFirstDeep = (\n    predicate: (value: unknown, path: string[]) => boolean,\n  ): [found: boolean, value: unknown, path: string[]] =>\n    findFirstDeep(this.spec, predicate);\n\n  private readonly hasProperRef = (schemaKey: string): boolean => {\n    const schemaPath = this.getSchemaPath(schemaKey);\n    const [hasProperRef] = this.findFirstDeep((value, path) => {\n      if (equalPath(path, schemaPath)) {\n        return false;\n      }\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        return (\n          refPath.basePath.length === 0 &&\n          matchPathPrefix(schemaPath, refPath.path)\n        );\n      }\n      return false;\n    });\n    return hasProperRef;\n  };\n\n  private readonly deleteUnusedSchemas = (): void => {\n    this._DEBUG(`deleteUnusedSchemas`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (!this.hasProperRef(schemaKey)) {\n          this.deleteAtPath(this.getSchemaPath(schemaKey));\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly rewriteSchemaAbsoluteRefs = (schemaKey: string): boolean => {\n    const schema = this.getSchema(schemaKey);\n    const schemaPath = this.getSchemaPath(schemaKey);\n    let dirty = false;\n    visitDeep(schema, (value) => {\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        if (\n          refPath.basePath.length === 0 &&\n          !matchPathPrefix(schemaPath, refPath.path)\n        ) {\n          const nextPath = getChildPath(schemaPath, ...refPath.path);\n          value.$ref = toRef({ basePath: ``, path: nextPath }).$ref;\n          dirty = true;\n        }\n      }\n    });\n    return dirty;\n  };\n\n  private readonly rewriteSchemasAbsoluteRefs = (): void => {\n    this._DEBUG(`rewriteSchemasAbsoluteRefs`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (this.rewriteSchemaAbsoluteRefs(schemaKey)) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly extractSchemaPathAsSchema = (\n    prevSchemaKey: string,\n    prevRelativePath: string[],\n    nextSchemaKey: string,\n  ): boolean => {\n    const prevPath = getChildPath(\n      this.getSchemaPath(prevSchemaKey),\n      ...prevRelativePath,\n    );\n\n    const prevValue = this.getAtPath(prevPath);\n    const nextPath = this.getSchemaPath(nextSchemaKey);\n\n    const [hasValueAtNextPath, valueAtNextPath] = this.getAtPathSafe(nextPath);\n\n    if (hasValueAtNextPath) {\n      if (!deepEqual(prevValue, valueAtNextPath)) {\n        this.throw(\n          new Error(\n            `schema(schemaKey='${nextSchemaKey}') already exists with a different value`,\n          ),\n        );\n      }\n    } else {\n      this.setAtPath(nextPath, prevValue);\n    }\n\n    this.setAtPath(prevPath, toRef({ basePath: ``, path: nextPath }));\n\n    let dirty = false;\n    visitDeep(this.spec, (value) => {\n      if (isRef(value)) {\n        const refPath = toRefPath(value.$ref);\n        if (\n          refPath.basePath.length === 0 &&\n          matchPathPrefix(prevPath, refPath.path)\n        ) {\n          value.$ref = toRef({\n            basePath: ``,\n            path: replacePathPrefix(prevPath, nextPath, refPath.path),\n          }).$ref;\n          dirty = true;\n        }\n      }\n    });\n    return dirty;\n  };\n\n  private readonly extractSchemaPropertiesAtKey = (\n    parentSchemaKey: string,\n    propertiesKey: ExtractSchemaPropertiesKey,\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): boolean => {\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      if (\n        propertiesKey === `properties` ||\n        propertiesKey === `additionalProperties` ||\n        propertiesKey === `patternProperties`\n      ) {\n        const properties = this.getSchema(parentSchemaKey)[propertiesKey];\n        if (isRecord(properties)) {\n          for (const k of Object.keys(properties)) {\n            const property = properties[k];\n            if (!isRef(property)) {\n              const nextSchemaKey = this.createSchemaKey(\n                parentSchemaKey,\n                [`${k}`],\n                schemaKeysOptions,\n              );\n              this.extractSchemaPathAsSchema(\n                parentSchemaKey,\n                [propertiesKey, k],\n                nextSchemaKey,\n              );\n              dirty = true;\n              break;\n            }\n          }\n        }\n      }\n      if (propertiesKey === `items`) {\n        const properties = this.getSchema(parentSchemaKey)[propertiesKey];\n        if (isRecord(properties) && !isRef(properties)) {\n          const nextSchemaKey = this.createSchemaKey(\n            parentSchemaKey,\n            [`item`],\n            schemaKeysOptions,\n          );\n          this.extractSchemaPathAsSchema(\n            parentSchemaKey,\n            [`items`],\n            nextSchemaKey,\n          );\n          dirty = true;\n        }\n      }\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly extractSchemaProperties = (\n    schemaKey: string,\n    propertiesKeys: ExtractSchemaPropertiesKey[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): boolean => {\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const propertiesKey of propertiesKeys) {\n        if (\n          this.extractSchemaPropertiesAtKey(\n            schemaKey,\n            propertiesKey,\n            schemaKeysOptions,\n          )\n        ) {\n          dirty = true;\n        }\n      }\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    for (const propertiesKey of propertiesKeys) {\n      if (\n        this.extractSchemaPropertiesAtKey(\n          schemaKey,\n          propertiesKey,\n          schemaKeysOptions,\n        )\n      ) {\n        this.extractSchemaProperties(\n          schemaKey,\n          propertiesKeys,\n          schemaKeysOptions,\n        );\n        return true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly extractSchemasProperties = (\n    propertiesKeys: ExtractSchemaPropertiesKey[],\n    schemaKeysOptions?: SchemaKeysOptions,\n  ): void => {\n    this._DEBUG(`extractSchemasProperties`);\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const schemaKey of this.getSchemaKeys()) {\n        if (\n          this.extractSchemaProperties(\n            schemaKey,\n            propertiesKeys,\n            schemaKeysOptions,\n          )\n        ) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  private readonly mergeRef = (prev$ref: string): boolean => {\n    const [schema, next$ref] = this.resolveRef(prev$ref);\n    let globalDirty = false;\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      visitDeep(this.spec, (value, path) => {\n        if (value !== schema && deepEqual(value, schema)) {\n          this.setAtPath(path, {\n            $ref: next$ref,\n          });\n          dirty = true;\n        }\n      });\n      if (dirty) {\n        globalDirty = true;\n      }\n    }\n    return globalDirty;\n  };\n\n  private readonly mergeRefs = ($refs: string[]): void => {\n    let dirty = true;\n    while (dirty) {\n      dirty = false;\n      for (const $ref of $refs) {\n        if (this.mergeRef($ref)) {\n          dirty = true;\n          break;\n        }\n      }\n    }\n  };\n\n  public readonly transformWithTimings = (\n    opts: TransformOptions = {},\n  ): TransformWithTimingsResult => {\n    const [\n      {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n      },\n      total,\n    ] = withTimings(() => {\n      const [, rewriteSchemasAbsoluteRefs] = withTimings(() => {\n        if (opts.rewriteSchemasAbsoluteRefs === false) {\n          return;\n        }\n        this.rewriteSchemasAbsoluteRefs();\n      });\n\n      const [, mergeRefs] = withTimings(() => {\n        if (opts.mergeRefs) {\n          this.mergeRefs(opts.mergeRefs.map((ref) => ref.$ref));\n        }\n      });\n\n      this._DEBUG({ mergeRefs });\n\n      this._DEBUG({ rewriteSchemasAbsoluteRefs });\n\n      const [, extractSchemasProperties] = withTimings(() => {\n        if (opts.extractSchemasProperties === false) {\n          return;\n        }\n        const extractSchemasPropertiesKeys = !Array.isArray(\n          opts.extractSchemasProperties,\n        )\n          ? defaultExtractSchemaPropertiesKey\n          : opts.extractSchemasProperties;\n        this.extractSchemasProperties(\n          extractSchemasPropertiesKeys,\n          opts.schemaKeys,\n        );\n      });\n\n      this._DEBUG({ extractSchemasProperties });\n\n      const [, deleteUnusedSchemas] = withTimings(() => {\n        if (opts.deleteUnusedSchemas === false) {\n          return;\n        }\n        this.deleteUnusedSchemas();\n      });\n\n      this._DEBUG({ deleteUnusedSchemas });\n\n      return {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n      };\n    });\n\n    this._DEBUG({ total });\n\n    return {\n      spec: this.spec,\n      timings: {\n        rewriteSchemasAbsoluteRefs,\n        extractSchemasProperties,\n        mergeRefs,\n        deleteUnusedSchemas,\n        total,\n      },\n    };\n  };\n\n  public readonly transform = (opts: TransformOptions = {}): Spec =>\n    this.transformWithTimings(opts).spec;\n}\n"],"mappings":"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"}