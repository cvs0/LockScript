{"version":3,"file":"Path.js","names":["_util","require","stringifyPath","path","join","exports","equalPath","a","b","length","k","getParentPath","Error","slice","getChildPath","childPath","getPathLastSegment","getChildSafe","current","segment","Array","isArray","index","parseInt","Number","isInteger","undefined","isRecord","Object","keys","includes","getAtPathSafe","obj","childFound","child","getAtPath","found","value","setAtPath","parentFound","parent","key","push","deleteAtPath","pop","matchPathPrefix","prefixPath","replacePathPrefix","prevPrefixPath","nextPrefixPath"],"sources":["../src/Path.ts"],"sourcesContent":["import { isRecord } from \"./util\";\n\nexport const stringifyPath = (path: string[]): string => path.join(`/`);\n\nexport const equalPath = (a: string[], b: string[]): boolean => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let k = 0; k < a.length; k++) {\n    if (a[k] !== b[k]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst getParentPath = <T extends string>(path: T[]): T[] => {\n  if (path.length === 0) {\n    throw new Error(`path='${stringifyPath(path)}' has no parent`);\n  }\n  return path.slice(0, -1);\n};\n\nexport const getChildPath = <T extends string>(\n  path: T[],\n  ...childPath: T[]\n): T[] => [...path, ...childPath];\n\nconst getPathLastSegment = <T extends string>(path: T[]): T => {\n  if (path.length === 0) {\n    throw new Error(`path='${stringifyPath}' has no parent`);\n  }\n  return path[path.length - 1];\n};\n\nconst getChildSafe = (\n  current: unknown,\n  segment: string,\n): [childFound: boolean, value: unknown] => {\n  if (Array.isArray(current)) {\n    const index = parseInt(segment);\n    if (!Number.isInteger(index)) {\n      throw new Error(\n        `current is an array but segment='${segment}' is not an integer`,\n      );\n    }\n    if (index < 0) {\n      throw new Error(`current is an array but index='${index}' is negative`);\n    }\n    return [typeof current[index] !== undefined, current[index]];\n  }\n  if (isRecord(current)) {\n    return [Object.keys(current).includes(segment), current[segment]];\n  }\n  return [false, undefined];\n};\n\nexport const getAtPathSafe = (\n  obj: unknown,\n  path: string[],\n): [valueFound: boolean, value: unknown] => {\n  let current = obj;\n\n  for (let k = 0; k < path.length; k++) {\n    const [childFound, child] = getChildSafe(current, path[k]);\n    if (!childFound) {\n      if (k !== path.length - 1) {\n        throw new Error(\n          `parent(path='${stringifyPath(path)}') has no child at segment='${\n            path[k]\n          }'`,\n        );\n      }\n      return [false, undefined];\n    }\n    current = child;\n  }\n  return [true, current];\n};\n\nexport const getAtPath = (obj: unknown, path: string[]): unknown => {\n  const [found, value] = getAtPathSafe(obj, path);\n  if (!found) {\n    throw new Error(`value(path='${stringifyPath(path)}') not found`);\n  }\n  return value;\n};\n\nexport const setAtPath = (\n  obj: unknown,\n  path: string[],\n  value: unknown,\n): void => {\n  const [parentFound, parent] = getAtPathSafe(obj, getParentPath(path));\n  if (!parentFound) {\n    throw new Error(`parent(path='${stringifyPath(path)}') not found`);\n  }\n  const key = getPathLastSegment(path);\n\n  if (Array.isArray(parent)) {\n    const index = parseInt(key);\n    if (!Number.isInteger(index)) {\n      throw new Error(\n        `key(path='${stringifyPath(path)}', key='${key}') is not an integer`,\n      );\n    }\n    if (index < 0) {\n      throw new Error(\n        `index(path='${stringifyPath(path)}', index='${index}') is negative`,\n      );\n    }\n    if (index > parent.length) {\n      throw new Error(\n        `index(path='${stringifyPath(\n          path,\n        )}', index='${index}') is out of bounds`,\n      );\n    }\n    if (index === parent.length) {\n      parent.push(value);\n    } else {\n      parent[index] = value;\n    }\n  } else if (isRecord(parent)) {\n    parent[key] = value;\n  } else {\n    throw new Error(`parent(path='${path}') is not an Array or a Record`);\n  }\n};\n\nexport const deleteAtPath = (obj: unknown, path: string[]): void => {\n  const [parentFound, parent] = getAtPathSafe(obj, getParentPath(path));\n  if (!parentFound) {\n    throw new Error(`parent(path='${stringifyPath(path)}') not found`);\n  }\n  const key = getPathLastSegment(path);\n\n  if (Array.isArray(parent)) {\n    const index = parseInt(key);\n    if (!Number.isInteger(index)) {\n      throw new Error(\n        `key(path='${stringifyPath(path)}', key='${key}') is not an integer`,\n      );\n    }\n    if (index !== parent.length) {\n      throw new Error(\n        `index(path='${stringifyPath(\n          path,\n        )}', index='${index}') is invalid: only last item of parent array can be deleted`,\n      );\n    }\n    parent.pop();\n  } else if (isRecord(parent)) {\n    if (!Object.keys(parent).includes(key)) {\n      throw new Error(\n        `key(path='${stringifyPath(path)}', key='${key}') not found in parent`,\n      );\n    }\n    delete parent[key];\n  } else {\n    throw new Error(\n      `parent(path='${stringifyPath(path)}') is not an Array or a Record`,\n    );\n  }\n};\n\nexport const matchPathPrefix = (\n  prefixPath: readonly string[],\n  path: string[],\n): boolean => {\n  if (path.length < prefixPath.length) {\n    return false;\n  }\n  for (let k = 0; k < prefixPath.length; k++) {\n    if (path[k] !== prefixPath[k]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const replacePathPrefix = <T extends string>(\n  prevPrefixPath: T[],\n  nextPrefixPath: T[],\n  path: T[],\n): T[] => {\n  if (!matchPathPrefix(prevPrefixPath, path)) {\n    throw new Error(\n      `path='${stringifyPath(\n        path,\n      )}' doesn't match prevPrefixPath='${stringifyPath(prevPrefixPath)}'`,\n    );\n  }\n  return [...nextPrefixPath, ...path.slice(prevPrefixPath.length)];\n};\n"],"mappings":"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"}